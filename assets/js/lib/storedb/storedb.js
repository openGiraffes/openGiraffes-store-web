class StoreDatabaseAPI{constructor(){this.stores=JSON.parse(window.localStorage.getItem("DatabaseURLs")),this.ratingServers=JSON.parse(window.localStorage.getItem("RatingServers")),this.currentStore={index:0,url:this.stores[0]},this.currentRatingServer={index:0,url:this.ratingServers[0]},this.db={categories:{all:{name:i18next.t("all-apps"),icon:"fas fa-store"}},apps:{objects:{},downloadCounts:{},ratings:{}},generatedAt:null}}async loadDb(){for(const e of this.stores){const t=await fetch(e);if(!t.ok)continue;this.currentStore.index=this.stores.indexOf(e),this.currentStore.url=e;const r=await t.json();if([2,3].includes(r.version)){this.db.generatedAt=r.generated_at,this.db.categories.all={name:i18next.t("all-apps"),icon:"fas fa-store"},Object.assign(this.db.categories,r.categories);for(const e of r.apps)this.db.apps.objects[e.name]=e;break}}}getAppsByCategory(e){const t=this;return new Promise((r,s)=>{this.db.categories.hasOwnProperty(e)||s(new Error('Category "'+e+'" does not exist!')),"all"==e&&r(this.db.apps.objects);const a=new Worker("assets/js/lib/storedb/workers/category-worker.js");a.onmessage=e=>{a.terminate(),r(e.data)},a.onerror=e=>{a.terminate(),s(e)},a.postMessage({apps:t.db.apps.objects,category:e})})}sortApps(e,t){const r=this;return new Promise((s,a)=>{const o=new Worker("assets/js/lib/storedb/workers/sort-worker.js");switch(o.onmessage=function(e){o.terminate(),s(e.data)},o.onerror=function(e){o.terminate(),a(e)},t){case"alphabetical":case"categorical":o.postMessage({sort:t,apps:e});break;case"popularity":o.postMessage({sort:t,apps:e,downloadCounts:r.db.apps.downloadCounts});break;case"ratings":o.postMessage({sort:t,apps:e,ratings:r.db.apps.ratings});break;default:console.warn("[StoreDb] Unable to sort, returning unsorted apps."),s(e)}})}searchApps(e){const t=this;return new Promise((r,s)=>{const a=new Worker("assets/js/lib/storedb/workers/search-worker.js");a.onmessage=e=>{a.terminate(),r(e.data)},a.onerror=e=>{a.terminate(),s(e)},a.postMessage({query:e,apps:t.db.apps.objects})})}async dlCountApp(e){await fetch(`${this.currentRatingServer.url}/download_counter/count/${e}`)}async getAppRatings(e){const t=await fetch(`${this.currentRatingServer.url}/ratings/${e}`);if(!t.ok)throw new Error(`Unable to fetch ratings for app ${e}.`);return await t.json()}async loginToRatingsAccount(e,t){if(!(await fetch(this.currentRatingServer.url+"/checkuser",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({username:e,logintoken:t})})).ok)throw new Error("Unable to login.")}async createRatingsAccount(e,t){if(!(await fetch(this.currentRatingServer.url+"/createuser",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({username:e,logintoken:t})})).ok)throw new Error("Unable to create account.")}async addNewRating(e,t,r,s,a){if(!(await fetch(`${this.currentRatingServer.url}/ratings/${r}/add`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({username:e,logintoken:t,points:s,description:a})})).ok)throw new Error(`Unable to create new rating for app ${r}.`)}}